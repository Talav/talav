package domain

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"strings"
)

const MediaIDPrefix = "med"

// MediaType represents the type of media content.
type MediaType string

// MediaMetadata represents file metadata stored as JSON.
type MediaMetadata struct {
	// FileSize is the size of the file in bytes
	FileSize int64 `json:"file_size"`
	// Width is the width in pixels (for images and videos)
	// 0 for non-image/video files
	Width int `json:"width"`
	// Height is the height in pixels (for images and videos)
	// 0 for non-image/video files
	Height int `json:"height"`
	// Extension is the file extension normalized (lowercase, no leading dot, e.g., "jpg", "png", "pdf")
	Extension string `json:"extension"`
	// Slug is the slugified filename without extension (e.g., "my-photo" from "My Photo.jpg")
	Slug string `json:"slug"`
	// MimeType is the MIME type of the file
	// Examples: "image/jpeg", "video/mp4", "application/pdf"
	// Used for proper content-type headers when serving files
	MimeType string `json:"mime_type"`
}

// ThumbnailMetadata represents metadata for a generated thumbnail.
type ThumbnailMetadata struct {
	// URL is the relative storage path where the thumbnail is stored
	URL string `json:"url"`
	// Width is the width in pixels
	Width int `json:"width"`
	// Height is the height in pixels
	Height int `json:"height"`
	// FileSize is the size of the thumbnail file in bytes
	FileSize int64 `json:"file_size"`
	// Extension is the file extension of the thumbnail
	Extension string `json:"extension"`
}

const (
	// MediaTypeImage represents image files (jpg, png, gif, webp, etc.)
	MediaTypeImage MediaType = "image"
	// MediaTypeVideo represents video files (mp4, webm, mov, etc.)
	MediaTypeVideo MediaType = "video"
	// MediaTypeFile represents generic file types (pdf, doc, etc.)
	MediaTypeFile MediaType = "file"
)

// Media represents a media file entry in the domain layer
// This is the aggregate root for media management
// Media instances are mostly immutable - only description and metadata can change.
type Media struct {
	// ID is the unique identifier for the media entry
	// Format: "med_<base64>" (generated by media.GenerateID)
	ID string `json:"id" gorm:"primaryKey"`

	// Preset is used to define processing settings like image resizing and thumbnail generation.
	// Examples: "default", "gallery", "product", "avatar", "document"
	// This allows applying specific processing rules based on the media's purpose.
	Preset string `json:"preset" gorm:"index"`

	// Provider is the name of the provider used to process this media.
	// This is stored so we know how to process the file when reading/deleting.
	Provider string `json:"provider" gorm:"index"`

	// Type indicates the media type (image, video, or file)
	// Determines how the media is processed and displayed
	Type MediaType `json:"type" gorm:"column:type;index"`

	// OriginalFileName is the name of the file when it was originally uploaded by the user.
	// This is stored for reference, while FileName is the generated, sanitized name.
	OriginalFileName string `json:"original_file_name" gorm:"column:original_file_name"`

	// FileName is the generated, sanitized, and unique name of the file in storage.
	FileName string `json:"file_name" gorm:"column:file_name"`

	// URL is the relative storage path where the file is stored.
	// Example: "gallery/med_123/photo_20240101120000.jpg"
	// The full CDN/HTTP link will be constructed at the application/presentation layer.
	URL string `json:"url" gorm:"column:url"`

	// Metadata stores file metadata as JSON (file size, dimensions, extension, mime type)
	// Stored as JSON in database, similar to Thumbnails
	Metadata MediaMetadata `json:"metadata" gorm:"column:metadata;serializer:json"`

	// Description provides accessibility text and metadata
	// Used for alt text in images, video descriptions, etc.
	// Important for SEO and accessibility compliance. This is mutable.
	Description string `json:"description" gorm:"column:description"`

	// Thumbnails stores metadata for generated thumbnails as JSON
	// Format: map[string]ThumbnailMetadata where key is the format name
	// Example: {"format_name1": {"url": "path/to/thumb.jpg", "width": 100, "height": 100, "file_size": 1234}}
	Thumbnails map[string]ThumbnailMetadata `json:"thumbnails,omitempty" gorm:"column:thumbnails;serializer:json"`

	// CreatedAt is the timestamp when the media entry was created
	// Automatically set by GORM on creation
	CreatedAt int64 `json:"created_at" gorm:"autoCreateTime"`

	// UpdatedAt is the timestamp when the media entry was last updated
	// Automatically updated by GORM on save
	UpdatedAt int64 `json:"updated_at" gorm:"autoUpdateTime"`

	// DeletedAt is the timestamp when the media entry was soft-deleted
	// nil if not deleted, set to timestamp if soft-deleted
	// Allows for soft delete functionality
	DeletedAt *int64 `json:"deleted_at,omitempty" gorm:"index"`
}

// NewMedia creates a new Media entity with generated ID and validation
// This is the proper way to create media entries in the domain.
func NewMedia(preset, provider string, mediaType MediaType, originalFileName, fileName, url string, fileSize int64, mimeType string, width, height int, extension, slug, description string) (*Media, error) {
	// Business validation
	if preset == "" {
		return nil, fmt.Errorf("preset is required")
	}
	if provider == "" {
		return nil, fmt.Errorf("provider is required")
	}
	if mediaType == "" {
		return nil, fmt.Errorf("media type is required")
	}
	if originalFileName == "" {
		return nil, fmt.Errorf("original file name is required")
	}
	if slug == "" {
		return nil, fmt.Errorf("slug is required")
	}
	// URL can be empty initially and set after file storage

	// Normalize extension: remove leading dot and convert to lowercase
	normalizedExt := strings.TrimPrefix(strings.ToLower(extension), ".")

	// Generate storage filename from slug and extension
	storageFileName := fmt.Sprintf("%s.%s", slug, normalizedExt)

	return &Media{
		ID:               generateID(MediaIDPrefix),
		Preset:           preset,
		Provider:         provider,
		Type:             mediaType,
		OriginalFileName: originalFileName,
		FileName:         storageFileName,
		URL:              url,
		Metadata: MediaMetadata{
			FileSize:  fileSize,
			Width:     width,
			Height:    height,
			Extension: normalizedExt,
			Slug:      slug,
			MimeType:  mimeType,
		},
		Description: description,
	}, nil
}

// UpdateDescription updates the description/alt text.
func (m *Media) UpdateDescription(description string) {
	m.Description = description
	// UpdatedAt will be set by GORM
}

// IsImage returns true if the media type is image.
func (m *Media) IsImage() bool {
	return m.Type == MediaTypeImage
}

// IsVideo returns true if the media type is video.
func (m *Media) IsVideo() bool {
	return m.Type == MediaTypeVideo
}

// GetExtension returns the normalized file extension (lowercase, no leading dot, e.g., "jpg", "png", "pdf").
func (m *Media) GetExtension() string {
	return m.Metadata.Extension
}

// GetSlug returns the slugified filename without extension (e.g., "my-photo" from "My Photo.jpg").
func (m *Media) GetSlug() string {
	return m.Metadata.Slug
}

// MediaView represents a Media entity enriched with infrastructure layer fields.
type MediaView struct {
	*Media
	PublicURL string
}

func (m *MediaView) GetPublicURL() string {
	return fmt.Sprintf("%s/%s", m.PublicURL, m.URL)
}

// generateID generates a unique ID with the given prefix.
// Format: prefix_base64url (URL-safe, no padding).
func generateID(prefix string) string {
	// Generate 12 random bytes (96 bits)
	b := make([]byte, 12)
	_, _ = rand.Read(b)

	// Encode to base64url (URL-safe, no padding)
	encoded := base64.RawURLEncoding.EncodeToString(b)

	return prefix + "_" + encoded
}
